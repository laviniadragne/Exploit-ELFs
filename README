Nume: Dragne Lavinia-Stefana
Grupa: 324 CA

		INTRODUCERE IN ORGANIZAREA CALCULATOARELOR SI LIMBAJ DE ASAMBLARE
					Tema #4 - "Exploit ELFs"


	Prezentarea solutiei:

		Task 1 - Analiza binarului

	Adresa functiei vulnerabile este 080492f8. Analizand binarul nice cu ghidra, se
identifica in main apelarea mai multor functii. In cea de-a doua functie apelata,
FUN_080492f8, se aloca pe stiva un vector de 269 bytes si se citesc, cu ajutorul functiei
read, 281 de bytes. Astfel, se realizeaza un buffer overflow, pentru ca se depaseste prin
citire, limita superioara a vectorului. In final, vor fi suprascrisi, de pe stiva, 12 bytes.
Astfel, aceasta functie va fi vulnerabila unui atac.


		Task 2  - Spargerea binarului

	Flag gasit: NICE_FLAG{baa473a9f9644ce3b811b4a05fa3a271}
	Functia din main vulnerabila este cea de-a doua. In cadrul primei functii se citesc
de la tastatura 0xba(186) caractere, iar in cadrul celei de-a doua, sunt alocati pe stiva
pentru vectorul auStack273 269 de bytes si cititi 281.
	Adunand cele 2 valori de bytes folositi, rezultatul a fost 455. In nice_payloader am
scris, folosind python, 455 caractere random, ce vor fi utilizate ca si garbage. Pentru a
suprascrie adresa vechiul ebp, pus pe stiva si adresa de return voi mai adauga 8 caractere
random, in payloader. In total vor fi 463 bytes generati. La finalul acestora, pentru a 
suprascrie valoarea parametrului param_1 si a apela functia de print_flag, se adauga, in format
little endian, valoarea adresei functiei de print_flag, aceasta fiind 08049291.


		Task 3	- Spargerea binarului v2 
	Flag gasit: NAUGHTY_FLAG{a442bf46b239998eadaeaaf5996f1eae}
	Functia vulnerabila este cea de-a treia apelata, din main, FUN_08049332 deoarece
citeste 418 bytes intr-un vector, desi acesta a fost alocat de doar 307, putandu-se astfel
suprascrie valori de pe stiva, de catre un atacator.
	Pentru a sparge binarul este nevoie ca primele 2 functii din main sa se execute corect.
Acestea contin o conditie de tip if, ce compara o valoare citita de la tastatura cu un numar
hexazecimal si in cazul in care nu sunt egale, executia programului se opreste. Deci in
payloader-ul naughty, pe pozitiile corespunzatoare, trebuie sa scriem valorile din hexazecimal.
	Concret, prima functie din main, de la adresa 080492de, conform codului atasat, obtinut
folosind comanda objdump, aloca 0xa9 bytes si citeste 0x7e bytes. Compara numarul de la ebp-0x57
cu 0x27a2d0e2 si daca sunt egale programul se executa in continuare. 

 80492de:	55                   	push   %ebp
 80492df:	89 e5                	mov    %esp,%ebp
 80492e1:	81 ec a9 00 00 00    	sub    $0xa9,%esp
 80492e7:	89 e2                	mov    %esp,%edx
 80492e9:	6a 7e                	push   $0x7e
 80492eb:	52                   	push   %edx
 80492ec:	6a 00                	push   $0x0
 80492ee:	e8 3d fd ff ff       	call   8049030 <read@plt>
 80492f3:	81 7d a1 e2 d0 a2 27 	cmpl   $0x27a2d0e2,-0x5f(%ebp)
 80492fa:	74 07                	je     8049303 <print_flag+0x72>
 80492fc:	6a 01                	push   $0x1
 80492fe:	e8 4d fd ff ff       	call   8049050 <exit@plt>
 8049303:	c9                   	leave  
 8049304:	c3                   	ret    



	Astfel, in payloader introduc, pentru prima functie, 0xa9-0x57 bytes = 82 bytes, apoi
numarul, scris in format little endian, 0x27a2d0e2. La final, adaug restul de bytes pana la
0x7e, ceruti de functia read, pentru a se continua executia programului cu cea de-a doua
functie.
	In mod identic se procedeaza si pentru a 2-a functie.
	Pentru cea de-a treia, cea vulnerabila, se scriu in payloader numarul de bytes alocati
pe stiva, anume 307 bytes. Se respecta, intocmai ca si mai sus, numarul (si anume, aici,
0xdbca5f37) ce trebuie pus pe pozitia corespunzatoare, pentru a nu se respecta conditia din if.
Se suprascrie pointerul (*local_73), functiei apelata (ce afiseaza mesajul All_done!_Bye-bye)
cu valoarea adresei functiei de print_flag si anume, 08049291, in format little endian. Astfel,
se obtine printata pe ecran, in urma rularii executabilului, valoare flag-ului.



		Task 4	- Shellcode

	Am generat payload-ul naughty_shellcode astfel incat, din binarul naughty, se poate
obtine un shell.
	Payload-ul este generat folosind comanda python: 
python -c 'print "l"*74 + "\xe2\xd0\xa2\x27" + "l"*180 + "\xdf\xe4\x8d\x41" +
"l"*411 +"\x69\xce\xff\xff" + "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb"\
"\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89"\
"\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd"\
"\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f"\
"\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42" + "l"*41 + "\x37\x5f\xca\xdb"' >
naughty_shellcode
	Aceasta a fost construita dupa o logica similara task-ului 3, folosindu-se litera "l",
ca si garbage pentru apelul lui read, din primele 2 functii anterior apelate, celei
vulnerabile si inserarea pe pozitiile corespunzatoare a valorilor in hexazecimal pentru a nu
fi indeplinite conditiile de intrerupere ale programului, din if. 
	Spre deosebire de task-ul 3, in cea de-a treia functie nu mai sunt inserati 96 de bytes
garbage, ci este injectat codul unei functii ce deschide un shell, de dimensiune 55 bytes si
alti 41 bytes, garbage, acestia fiind restul pana la 96. Ulterior, se introduce pe pozitia 
corespunzatoare valoarea 0xdbca5f37, scrisa in little endian, pentru a nu fi indeplinita
conditia din if, din functia vulnerabila si programul sa-si continue executia. Similar cu 
task-ul 3, este suprascris pointerul "local_73". De data aceasta insa, nu este introdusa adresa
functiei de print_flag, ci adresa unde a fost inserat shellcode-ul. Aceasta se afla cu gdb,
inspectand registrul ecx, unde este stocat shellcode-ul.
	In final, binarul va apela codul functiei de deschidere a unui terminal.


	Referinte:
Shellcode-ul este preluat de la: https://www.vividmachines.com/shellcode/shellcode.html











